<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>touch pop Â· vanilla bubble game</title>
  <style>
    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(145deg, #1b3358 0%, #0d1c33 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
      touch-action: pan-y; /* allow gentle vertical pull, but canvas will block */
    }
    .game-wrapper {
      width: 100%;
      max-width: 420px;
      padding: 12px 10px 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 60px;
      padding: 8px 16px;
      margin-bottom: 16px;
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }
    .score-box {
      background: #f2c94c;
      color: #1e2b41;
      font-weight: 800;
      font-size: 1.7rem;
      padding: 4px 20px;
      border-radius: 40px;
      letter-spacing: 1px;
      text-shadow: 2px 2px 0 rgba(255,255,255,0.3);
      box-shadow: inset 0 -3px 0 #b38f2e;
    }
    .reset-btn {
      background: rgba(255,255,255,0.25);
      border: 2px solid rgba(255,255,255,0.7);
      color: white;
      font-size: 1.3rem;
      font-weight: 600;
      width: 56px;
      height: 56px;
      border-radius: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: 0.15s;
      box-shadow: 0 6px 0 rgba(0,0,0,0.2);
      touch-action: manipulation;
    }
    .reset-btn:active {
      transform: translateY(5px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.2);
      background: rgba(255,255,255,0.4);
    }
    .canvas-container {
      width: 100%;
      background: #8fc5e9;
      border-radius: 36px;
      box-shadow: 0 20px 30px rgba(0, 0, 0, 0.6), inset 0 -3px 0 rgba(0,0,0,0.2);
      padding: 8px;
      background: #70a9d1;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      background: radial-gradient(circle at 30% 30%, #b3e2ff, #4790c0);
      border-radius: 28px;
      touch-action: none;  /* kills all browser scrolling/zooming inside canvas */
      cursor: pointer;
      box-shadow: inset 0 -6px 0 rgba(0,0,0,0.2);
    }
    .instruction {
      color: rgba(255,255,255,0.9);
      margin-top: 18px;
      font-weight: 500;
      text-shadow: 0 2px 2px black;
      display: flex;
      gap: 12px;
      font-size: 1.1rem;
    }
    .instruction span {
      background: rgba(255,255,255,0.2);
      padding: 6px 18px;
      border-radius: 40px;
      backdrop-filter: blur(4px);
    }
    /* disable pull-to-refresh etc on canvas */
    .no-touch-action {
      touch-action: none;
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <div class="header">
      <div class="score-box" id="scoreDisplay">0</div>
      <div class="reset-btn" id="resetButton" role="button" aria-label="restart game">â†»</div>
    </div>
    <div class="canvas-container">
      <canvas id="gameCanvas" width="400" height="600"></canvas>
    </div>
    <div class="instruction">
      <span>ðŸ‘† pop with fingers</span>
      <span>âœ¨ multiâ€‘touch</span>
    </div>
  </div>
  <script>
    (function() {
      // ----- canvas & context -----
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      // fixed logical resolution (will be scaled by CSS)
      const CANVAS_W = 400;
      const CANVAS_H = 600;
      canvas.width = CANVAS_W;
      canvas.height = CANVAS_H;

      // ----- game state -----
      let bubbles = [];                 // array of bubble objects
      let score = 0;
      const scoreElement = document.getElementById('scoreDisplay');

      // ----- bubble parameters -----
      const MIN_RADIUS = 15;
      const MAX_RADIUS = 26;
      const MIN_SPEED = 0.7;
      const MAX_SPEED = 2.4;
      const SPAWN_INTERVAL_MS = 750;    // ms between spawns

      // ----- time based spawn -----
      let lastSpawnTime = performance.now();

      // ----- helper: random range -----
      const rand = (min, max) => Math.random() * (max - min) + min;
      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

      // ----- create a new bubble (spawn at bottom) -----
      function createBubble() {
        const radius = rand(MIN_RADIUS, MAX_RADIUS);
        const x = rand(radius, CANVAS_W - radius);
        const y = CANVAS_H - radius;               // appear at bottom edge
        const speed = rand(MIN_SPEED, MAX_SPEED);
        // random cheerful color (HSL)
        const hue = randInt(0, 360);
        const sat = 70 + randInt(0, 25);
        const light = 60 + randInt(0, 20);
        return {
          x, y,
          r: radius,
          speed,
          color: `hsl(${hue}, ${sat}%, ${light}%)`,
        };
      }

      // ----- update bubble positions, remove offscreen (top) -----
      function updateBubbles() {
        for (let i = bubbles.length - 1; i >= 0; i--) {
          const b = bubbles[i];
          // move upward
          b.y -= b.speed;
          // if completely above canvas (even accounting for radius), remove
          if (b.y + b.r < 0) {
            bubbles.splice(i, 1);
          }
        }
      }

      // ----- spawn new bubbles based on time -----
      function spawnBubbles(now) {
        if (now - lastSpawnTime >= SPAWN_INTERVAL_MS) {
          bubbles.push(createBubble());
          lastSpawnTime = now;
        }
      }

      // ----- drawing -----
      function draw() {
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

        // draw subtle water surface effect
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(0, 0, CANVAS_W, 10);

        // draw each bubble with glow
        for (let b of bubbles) {
          // shadow for depth
          ctx.shadowColor = 'rgba(0,0,0,0.25)';
          ctx.shadowBlur = 12;
          ctx.shadowOffsetY = 3;

          // main bubble
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
          ctx.fillStyle = b.color;
          ctx.fill();

          // shiny highlight (small white oval)
          ctx.shadowBlur = 0;    // no shadow for highlight
          ctx.shadowOffsetY = 0;
          ctx.beginPath();
          ctx.ellipse(b.x - b.r*0.2, b.y - b.r*0.2, b.r*0.2, b.r*0.1, 0, 0, 2*Math.PI);
          ctx.fillStyle = 'rgba(255,255,255,0.45)';
          ctx.fill();

          // tiny sparkle
          ctx.beginPath();
          ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.08, 0, 2*Math.PI);
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.fill();
        }

        // reset shadow
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        // optional: draw very subtle grid lines for fun (barely visible)
        ctx.strokeStyle = 'rgba(255,255,240,0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i < CANVAS_H; i += 30) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(CANVAS_W, i);
          ctx.stroke();
        }
      }

      // ----- map client coordinates to canvas pixel coordinates -----
      function getCanvasCoords(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        // check if touch is inside canvas area (with a tiny margin)
        if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
          return null;
        }
        // scale factors: logical size / displayed size
        const scaleX = CANVAS_W / rect.width;
        const scaleY = CANVAS_H / rect.height;
        // relative position inside canvas element (0..1)
        const relX = (clientX - rect.left) / rect.width;
        const relY = (clientY - rect.top) / rect.height;
        // clamp to [0,1] for safety
        const canvasX = Math.min(CANVAS_W, Math.max(0, relX * CANVAS_W));
        const canvasY = Math.min(CANVAS_H, Math.max(0, relY * CANVAS_H));
        return { x: canvasX, y: canvasY };
      }

      // ----- core touch/mouse handler: pop bubbles at given coordinates -----
      function popBubblesAt(clientPositions) {
        if (!clientPositions.length) return;

        const toRemove = new Set();   // use bubble objects as keys

        for (let pos of clientPositions) {
          const canvasPt = getCanvasCoords(pos.clientX, pos.clientY);
          if (!canvasPt) continue;

          // check all bubbles for collision
          for (let bubble of bubbles) {
            const dx = canvasPt.x - bubble.x;
            const dy = canvasPt.y - bubble.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= bubble.r) {
              toRemove.add(bubble);   // mark for removal (no duplicates)
            }
          }
        }

        if (toRemove.size > 0) {
          // filter out the popped bubbles
          bubbles = bubbles.filter(b => !toRemove.has(b));
          // increase score by number of popped bubbles
          score += toRemove.size;
          scoreElement.textContent = score;
        }
      }

      // ----- EVENT HANDLERS (touch & mouse) -----

      // touch start: get all touches
      function onTouchStart(e) {
        e.preventDefault();   // kill scroll, zoom, etc.
        const touches = e.touches;
        if (!touches) return;

        const clientPositions = [];
        for (let i = 0; i < touches.length; i++) {
          const touch = touches[i];
          clientPositions.push({
            clientX: touch.clientX,
            clientY: touch.clientY,
          });
        }
        popBubblesAt(clientPositions);
      }

      // mouse down (for desktop testing)
      function onMouseDown(e) {
        e.preventDefault();   // prevent accidental drag / selection
        // only left button (button === 0)
        if (e.button !== 0) return;
        const clientPositions = [{
          clientX: e.clientX,
          clientY: e.clientY,
        }];
        popBubblesAt(clientPositions);
      }

      // additional touch/move prevent to be super safe (avoid pull-to-refresh)
      function onTouchMove(e) {
        e.preventDefault();
      }
      function onTouchEnd(e) {
        e.preventDefault();   // optional, but safe
      }
      function onTouchCancel(e) {
        e.preventDefault();
      }

      // disable context menu on canvas (long press menu)
      function onContextMenu(e) {
        e.preventDefault();
      }

      // ----- reset game -----
      function resetGame() {
        bubbles = [];
        score = 0;
        scoreElement.textContent = '0';
        lastSpawnTime = performance.now();  // avoid spawn burst
        // optional: add a couple starting bubbles for instant fun
        for (let i = 0; i < 3; i++) {
          bubbles.push(createBubble());
        }
      }

      // ----- animation loop (update + draw) -----
      function gameLoop(now) {
        // spawn new bubbles based on timer
        spawnBubbles(now);
        // move bubbles
        updateBubbles();
        // draw everything
        draw();
        // next frame
        requestAnimationFrame(gameLoop);
      }

      // ----- attach listeners -----
      function initGame() {
        // Touch events (mobile)
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchCancel, { passive: false });

        // Mouse event (desktop)
        canvas.addEventListener('mousedown', onMouseDown);

        // Disable right-click / context menu on canvas
        canvas.addEventListener('contextmenu', onContextMenu);

        // Reset button
        document.getElementById('resetButton').addEventListener('click', (e) => {
          resetGame();
        });
        // also prevent any stray touch events on reset button from bubbling to canvas
        document.getElementById('resetButton').addEventListener('touchstart', (e) => {
          e.stopPropagation();   // avoid triggering canvas pop
        }, { passive: true });

        // initial reset gives some bubbles
        resetGame();

        // start the loop
        requestAnimationFrame(gameLoop);
      }

      // start everything after DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGame);
      } else {
        initGame();
      }

      // optional: handle window resize (nothing special, just redraw loop handles it)
      // but we must keep canvas rect mapping accurate â€“ fine.
    })();
  </script>
</body>
</html>